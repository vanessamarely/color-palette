# GitHub Copilot Configuration for Angular 20 + Vite Project

## Project Context
This is an Angular 20 application using Vite as the build tool, with Server-Side Rendering (SSR) enabled and Google Gemini AI integration.

## Key Technologies & Versions
- Angular: 20.3.9 (Latest stable)
- TypeScript: 5.6+
- Vite: Integrated build tool (replaces Webpack)
- Node.js: 18+ (Required for SSR)
- Google Gemini AI: 2.0-flash-exp model

## Angular 20 Specific Features to Use

### 1. Control Flow Syntax
```html
@if (condition) {
  <div>Content</div>
} @else {
  <div>Alternative</div>
}

@for (item of items; track item.id) {
  <div>{{ item.name }}</div>
}

@switch (value) {
  @case ('option1') { <div>Option 1</div> }
  @case ('option2') { <div>Option 2</div> }
  @default { <div>Default</div> }
}
```

### 2. Signals for Component State
```typescript
import { signal, computed, effect } from '@angular/core';

protected readonly loading = signal<boolean>(false);
protected readonly data = signal<User[]>([]);
protected readonly filteredData = computed(() => 
  this.data().filter(user => user.active)
);

constructor() {
  effect(() => {
    console.log('Data changed:', this.data());
  });
}
```

### 3. Standalone Components
```typescript
@Component({
  selector: 'app-example',
  standalone: true,
  imports: [CommonModule, ReactiveFormsModule],
  template: `<div>Content</div>`
})
export class ExampleComponent {}
```

### 4. Modern Dependency Injection
```typescript
import { inject } from '@angular/core';

export class MyComponent {
  private readonly http = inject(HttpClient);
  private readonly router = inject(Router);
}
```

### 5. Strict TypeScript
```typescript
interface User {
  readonly id: number;
  readonly name: string;
  readonly email: string;
}

protected readonly users = signal<User[]>([]);
```

## File Structure Conventions

```
src/app/
├── components/          # Reusable standalone components
├── pages/              # Route components
├── services/           # Business logic services
├── shared/
│   ├── types.ts       # TypeScript interfaces & types
│   ├── constants.ts   # App constants
│   └── utils.ts       # Pure utility functions
├── app.component.ts   # Root component (standalone)
├── app.config.ts     # App configuration
└── app.routes.ts     # Route definitions
```

## Coding Standards

### TypeScript Rules
- Use `readonly` for immutable properties
- Prefer `const` assertions for literal types
- Use discriminated unions for complex state
- Always type function parameters and return types
- Use `strict: true` in tsconfig.json

### Angular Rules
- Prefix private members with `private readonly`
- Prefix protected members with `protected readonly`
- Use OnPush change detection when possible
- Implement lifecycle interfaces explicitly
- Use trackBy functions in @for loops

### Naming Conventions
- Components: PascalCase with 'Component' suffix
- Services: PascalCase with descriptive name
- Signals: camelCase with descriptive name
- Constants: UPPER_SNAKE_CASE
- Types/Interfaces: PascalCase

## Vite Specific Considerations

### Environment Variables
```typescript
const apiKey = import.meta.env['VITE_API_KEY'];
```

### Dynamic Imports
```typescript
const LazyComponent = () => import('./lazy.component');

{
  path: 'feature',
  loadComponent: () => import('./feature/feature.component')
    .then(m => m.FeatureComponent)
}
```

## SSR Best Practices

### Server-Safe Code
```typescript
import { isPlatformBrowser } from '@angular/common';
import { PLATFORM_ID, inject } from '@angular/core';

export class MyComponent {
  private readonly platformId = inject(PLATFORM_ID);
  
  someMethod() {
    if (isPlatformBrowser(this.platformId)) {
      localStorage.setItem('key', 'value');
    }
  }
}
```

### Hydration
```typescript
import { provideClientHydration, withEventReplay } from '@angular/platform-browser';

export const appConfig: ApplicationConfig = {
  providers: [
    provideClientHydration(withEventReplay()),
    // other providers
  ]
};
```

## AI Integration Patterns

### Error Handling
```typescript
try {
  const response = await this.aiService.generateContent(prompt);
  return this.parseResponse(response);
} catch (error) {
  if (error instanceof ColorGenerationError) {
    return this.getFallbackColors();
  }
  throw new ColorGenerationError('AI service failed', error);
}
```

### Type Safety for API Responses
```typescript
interface AIResponse {
  readonly success: boolean;
  readonly data: readonly string[];
  readonly fallback: boolean;
  readonly message?: string;
}

private validateAIResponse(response: unknown): response is AIResponse {
  return typeof response === 'object' 
    && response !== null 
    && 'success' in response
    && 'data' in response;
}
```

## Testing Patterns

### Component Testing with Signals
```typescript
it('should update signal value', () => {
  const component = new MyComponent();
  
  component.updateValue('new value');
  
  expect(component.value()).toBe('new value');
});
```

## Performance Optimizations

### Signal-based Change Detection
```typescript
@Component({
  changeDetection: ChangeDetectionStrategy.OnPush,
  template: `
    @if (loading()) {
      <div>Loading...</div>
    }
    @for (item of items(); track item.id) {
      <div>{{ item.name }}</div>
    }
  `
})
```

## Common Patterns to Suggest

1. **State Management**: Use signals for local state, services for global state
2. **Forms**: Always use Reactive Forms with strict typing
3. **HTTP**: Use HttpClient with proper error handling and typing
4. **Routing**: Use functional guards and lazy loading
5. **Styling**: Use CSS custom properties and modern layout techniques

Remember: This project prioritizes type safety, modern Angular patterns, and optimal performance with Vite.