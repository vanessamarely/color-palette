# Contexto del Proyecto para IA

## Stack Tecnológico
- **Angular**: 20.3.9 (Latest)
- **Build Tool**: Vite (integrado en Angular 17+)
- **TypeScript**: 5.6+
- **SSR**: Angular Universal con Node.js
- **Bundler**: Vite (reemplaza Webpack)

## Características de Angular 20

### Signals (Estable)
- Usar `signal()`, `computed()`, `effect()`
- Reemplaza observables para estado local
- Mejor rendimiento y detección de cambios

### Control Flow Syntax (Estable)
- Usar `@if`, `@for`, `@switch` en templates
- NO usar `*ngIf`, `*ngFor`, `*ngSwitch`
- Sintaxis nueva desde Angular 17

### Standalone Components (Por defecto)
- Todos los componentes deben ser standalone
- Usar `imports` array en lugar de NgModules
- NO usar `@NgModule` excepto para casos específicos

### Formularios
- Preferir Reactive Forms sobre Template-driven
- Usar `FormControl`, `FormGroup`, `FormBuilder`
- Tipado fuerte con TypeScript

### Inyección de Dependencias
- Usar `inject()` function en lugar de constructor injection
- Más funcional y mejor tree-shaking

## Buenas Prácticas Angular 20

### Tipado TypeScript
```typescript
protected readonly colors = signal<string[]>([]);
private readonly service = inject(MyService);
```

### Estructura de Componentes
```typescript
@Component({
  selector: 'app-example',
  standalone: true,
  imports: [CommonModule, ReactiveFormsModule],
  template: `
    @if (loading()) {
      <div>Cargando...</div>
    }
    @for (item of items(); track item.id) {
      <div>{{ item.name }}</div>
    }
  `
})
export class ExampleComponent {
  private readonly service = inject(SomeService);
  protected readonly loading = signal(false);
  protected readonly items = signal<Item[]>([]);
}
```

### Control Flow en Templates
```html
@if (condition) {
  <div>Contenido</div>
} @else if (otherCondition) {
  <div>Otro contenido</div>
} @else {
  <div>Default</div>
}

@for (item of items; track item.id; let i = $index) {
  <div>{{ item.name }} - {{ i }}</div>
}
```

### Signals y Observables
```typescript
// Signals para estado local
protected readonly loading = signal(false);
protected readonly data = signal<Data[]>([]);

// Observables para streams/HTTP
private readonly http = inject(HttpClient);
getData() {
  return this.http.get<Data[]>('/api/data');
}

// Convertir observable a signal cuando sea necesario
private readonly dataService = inject(DataService);
protected readonly data = toSignal(this.dataService.getData(), { initialValue: [] });
```

### Configuración Vite Específica

### Optimizaciones
- Vite usa ESM por defecto
- Hot Module Replacement (HMR) integrado
- Tree-shaking automático mejorado
- Build más rápido que Webpack

### Variables de Entorno
```typescript
const apiKey = import.meta.env['VITE_API_KEY'];
```

### Imports Dinámicos
```typescript
// ✅ CORRECTO - Lazy loading con Vite
const LazyComponent = () => import('./lazy.component');

// ✅ CORRECTO - Chunks optimizados
const routes: Routes = [
  {
    path: 'feature',
    loadComponent: () => import('./feature/feature.component')
  }
];
```

### SSR y Hydration

### Angular Universal
- SSR habilitado por defecto con `--ssr`
- Hydration automática con `provideClientHydration()`
- Renderizado isomorfo mejorado

### Configuración SSR
```typescript
export const appConfig: ApplicationConfig = {
  providers: [
    provideZoneChangeDetection({ eventCoalescing: true }),
    provideRouter(routes),
    provideClientHydration(withEventReplay()),
    provideHttpClient(withFetch())
  ]
};
```

## Estructura de Carpetas Recomendada

```
src/
├── app/
│   ├── components/          # Componentes reutilizables
│   ├── pages/              # Páginas/rutas principales
│   ├── services/           # Servicios de negocio
│   ├── shared/             # Utilidades compartidas
│   │   ├── interfaces/     # Tipos TypeScript
│   │   ├── utils/          # Funciones puras
│   │   └── constants/      # Constantes
│   ├── app.component.ts    # Componente raíz
│   ├── app.config.ts      # Configuración de la app
│   └── app.routes.ts      # Definición de rutas
├── environments/          # Configuraciones por entorno
└── assets/               # Recursos estáticos
```

### Testing con Angular 20

### Jest (Recomendado sobre Karma)
```typescript
it('should update signal value', () => {
  const component = new ExampleComponent();
  
  component.updateValue('new value');
  
  expect(component.value()).toBe('new value');
});
```

## Performance

### Optimizaciones Angular 20
- OnPush change detection por defecto
- Signals optimizan renders automáticamente
- Vite optimiza bundles mejor que Webpack
- Tree-shaking mejorado

### Lazy Loading
```typescript
const routes: Routes = [
  {
    path: 'feature',
    loadComponent: () => import('./feature/feature.component').then(m => m.FeatureComponent)
  }
];
```

## Comandos Específicos

### Desarrollo
```bash
ng serve                    # Desarrollo con Vite
ng build                   # Build de producción
ng build --watch          # Build con watch mode
```

### SSR
```bash
ng build                   # Build cliente y servidor
npm run serve:ssr         # Servir con SSR
```

---

**Nota para IA**: Este proyecto utiliza las características más modernas de Angular 20. Siempre usar la sintaxis nueva, signals para estado, componentes standalone, y seguir las convenciones de TypeScript estricto.